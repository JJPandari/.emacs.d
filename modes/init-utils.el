(use-package s
  :demand t)

(use-package dash
  :demand t)

(use-package move-text
  :demand t)

;;----------------------------------------------------------------------------
;; `after-load'
;;----------------------------------------------------------------------------
(if (fboundp 'with-eval-after-load)
    (defalias 'after-load 'with-eval-after-load)
  (defmacro after-load (feature &rest body)
    "After FEATURE is loaded, evaluate BODY."
    (declare (indent defun))
    `(eval-after-load ,feature
       '(progn ,@body))))

;;----------------------------------------------------------------------------
;; Interactive lambda shorthand.
;;----------------------------------------------------------------------------
(defmacro lambda! (&rest body)
  "A shortcut for inline interactive lambdas."
  (declare (doc-string 1))
  `(lambda () (interactive) ,@body))

;;----------------------------------------------------------------------------
;; Run in after-init-hook.
;;----------------------------------------------------------------------------
(defmacro after-init (&rest body)
  "A shortcut for adding to after-init-hook."
  (declare (doc-string 1))
  `(add-hook 'after-init-hook ,@body))

;;----------------------------------------------------------------------------
;; Handier way to add modes to auto-mode-alist
;;----------------------------------------------------------------------------
(defun add-auto-mode (mode &rest patterns)
  "Add entries to `auto-mode-alist' to use `MODE' for all given file `PATTERNS'."
  (dolist (pattern patterns)
    (add-to-list 'auto-mode-alist (cons pattern mode))))


;;----------------------------------------------------------------------------
;; String utilities missing from core emacs
;;----------------------------------------------------------------------------
(defun jester/string-all-matches (regex str &optional group)
  "Find all matches for `REGEX' within `STR', returning the full match string or group `GROUP'."
  (let ((result nil)
        (pos 0)
        (group (or group 0)))
    (while (string-match regex str pos)
      (push (match-string group str) result)
      (setq pos (match-end group)))
    result))


;;----------------------------------------------------------------------------
;; get region or symbol
;;----------------------------------------------------------------------------
(defun jester/region-or-symbol ()
  "Get active region or symbol at point."
  (if (region-active-p)
      (buffer-substring-no-properties
       (region-beginning) (region-end))
    (thing-at-point 'symbol t)))

;;----------------------------------------------------------------------------
;; run major mode hooks
;;----------------------------------------------------------------------------
(defun jester/run-major-mode-hooks ()
  "Run hooks for the current major mode."
  (interactive)
  (run-hooks (intern (format "%s-hook" major-mode))))

;;----------------------------------------------------------------------------
;; Merge imenus.
;;----------------------------------------------------------------------------
;; https://stackoverflow.com/a/21656063/4788022
(defun jester/merge-imenu (INDEX-FUN)
  "Merge major-mode-provided imenu, which is generated by `INDEX-FUN',
with traditional regex based imenu."
  (interactive)
  (let ((mode-imenu (funcall INDEX-FUN))
        (custom-imenu (imenu--generic-function imenu-generic-expression)))
    (append custom-imenu mode-imenu)))

;;----------------------------------------------------------------------------
;; Select the emacs frame (used in shell scripts).
;;----------------------------------------------------------------------------
(defun open-emacs-window ()
    "Switch to emacs frame."
    (select-frame-set-input-focus (selected-frame)))

;;----------------------------------------------------------------------------
;; add hook shorthand
;;----------------------------------------------------------------------------
(defmacro add-hook! (&rest args)
  "A convenience macro for `add-hook'. Takes, in order:

  1. Optional properties :local and/or :append, which will make the hook
     buffer-local or append to the list of hooks (respectively),
  2. The hooks: either an unquoted major mode, an unquoted list of major-modes,
     a quoted hook variable or a quoted list of hook variables. If unquoted, the
     hooks will be resolved by appending -hook to each symbol.
  3. A function, list of functions, or body forms to be wrapped in a lambda.

Examples:
    (add-hook! 'some-mode-hook 'enable-something)
    (add-hook! some-mode '(enable-something and-another))
    (add-hook! '(one-mode-hook second-mode-hook) 'enable-something)
    (add-hook! (one-mode second-mode) 'enable-something)
    (add-hook! :append (one-mode second-mode) 'enable-something)
    (add-hook! :local (one-mode second-mode) 'enable-something)
    (add-hook! (one-mode second-mode) (setq v 5) (setq a 2))
    (add-hook! :append :local (one-mode second-mode) (setq v 5) (setq a 2))

Body forms can access the hook's arguments through the let-bound variable
`args'."
  (declare (indent defun) (debug t))
  (let ((hook-fn 'add-hook)
        append-p local-p)
    (while (keywordp (car args))
      (pcase (pop args)
        (:append (setq append-p t))
        (:local  (setq local-p t))
        (:remove (setq hook-fn 'remove-hook))))
    (let ((hooks (doom--resolve-hook-forms (pop args)))
          (funcs
           (let ((val (car args)))
             (if (memq (car-safe val) '(quote function))
                 (if (cdr-safe (cadr val))
                     (cadr val)
                   (list (cadr val)))
               (list args))))
          forms)
      (dolist (fn funcs)
        (setq fn (if (symbolp fn)
                     `(function ,fn)
                   `(lambda (&rest _) ,@args)))
        (dolist (hook hooks)
          (push (if (eq hook-fn 'remove-hook)
                    `(remove-hook ',hook ,fn ,local-p)
                  `(add-hook ',hook ,fn ,append-p ,local-p))
                forms)))
      `(progn ,@(nreverse forms)))))

(defun doom--resolve-hook-forms (hooks)
  (cl-loop with quoted-p = (eq (car-safe hooks) 'quote)
           for hook in (doom-enlist (doom-unquote hooks))
           if (eq (car-safe hook) 'quote)
            collect (cadr hook)
           else if quoted-p
            collect hook
           else collect (intern (format "%s-hook" (symbol-name hook)))))

(defun doom-unquote (exp)
  "Return EXP unquoted."
  (while (memq (car-safe exp) '(quote function))
    (setq exp (cadr exp)))
  exp)

(defun doom-enlist (exp)
  "Return EXP wrapped in a list, or as-is if already a list."
  (if (listp exp) exp (list exp)))

;;----------------------------------------------------------------------------
;; describe keymap.
;;----------------------------------------------------------------------------
(defun describe-keymap (keymap &optional search-symbols-p)
  "Describe key bindings in KEYMAP.
Interactively, prompt for a variable that has a keymap value.
Completion is available for the variable name.

Non-interactively:
* KEYMAP can be such a keymap variable or a keymap.
* Non-nil optional arg SEARCH-SYMBOLS-P means that if KEYMAP is not a
  symbol then search all variables for one whose value is KEYMAP."
  (interactive (list (intern (completing-read "Keymap: " obarray
                                              (lambda (m) (and (boundp m)  (keymapp (symbol-value m))))
                                              t nil 'variable-name-history))))
  (unless (and (symbolp keymap)  (boundp keymap)  (keymapp (symbol-value keymap)))
    (if (not (keymapp keymap))
        (error "%sot a keymap%s"
               (if (symbolp keymap) (format "`%S' is n" keymap) "N")
               (if (symbolp keymap) " variable" ""))
      (let ((sym  nil))
        (when search-symbols-p
          (setq sym  (catch 'describe-keymap
                       (mapatoms (lambda (symb) (when (and (boundp symb)
                                                      (eq (symbol-value symb) keymap)
                                                      (not (eq symb 'keymap))
                                                      (throw 'describe-keymap symb)))))
                       nil)))
        (unless sym
          (setq sym  (gentemp "KEYMAP OBJECT (no variable) "))
          (set sym keymap))
        (setq keymap  sym))))
  (setq keymap  (or (condition-case nil (indirect-variable keymap) (error nil))  keymap)) ; Follow aliasing.
  (let* ((name  (symbol-name keymap))
         (doc   (if (fboundp 'help-documentation-property) ; Emacs 23+
                    (help-documentation-property keymap 'variable-documentation nil 'ADD-HELP-BUTTONS)
                  (documentation-property keymap 'variable-documentation)))
         (doc   (and (not (equal "" doc))  doc)))
    (help-setup-xref (list #'describe-keymap keymap)
                     (if (or (> emacs-major-version 23) ; Emacs 23.1 `called-interactively' accepts no arg.
                             (and (= emacs-major-version 23)  (> emacs-minor-version 1)))
                         (called-interactively-p 'interactive)
                       (interactive-p)))
    (if (fboundp 'with-help-window)
        (with-help-window (help-buffer)
          (princ name) (terpri) (princ (make-string (length name) ?-)) (terpri) (terpri)
          (when doc
            (when (boundp 'Info-virtual-files) ; Emacs 23.2+
              (with-current-buffer "*Help*"    ; Link to manuals.
                (Info-make-manuals-xref name nil nil (not (if (or (> emacs-major-version 23)
                                                                  (and (= emacs-major-version 23)
                                                                       (> emacs-minor-version 1)))
                                                              (called-interactively-p 'interactive)
                                                            (interactive-p))))))
            (princ doc) (terpri) (terpri))
          ;; Use `insert' instead of `princ', so control chars (e.g. \377) insert correctly.
          (with-current-buffer "*Help*" (insert (substitute-command-keys (concat "\\{" name "}")))))
      (with-output-to-temp-buffer "*Help*"
        (princ name) (terpri) (princ (make-string (length name) ?-)) (terpri) (terpri)
        (when doc
          (when (boundp 'Info-virtual-files) ; Emacs 23.2+
            (with-current-buffer "*Help*"    ; Link to manuals.
              (Info-make-manuals-xref name nil nil (not (if (or (> emacs-major-version 23)
                                                                (and (= emacs-major-version 23)
                                                                     (> emacs-minor-version 1)))
                                                            (called-interactively-p 'interactive)
                                                          (interactive-p))))))
          (princ doc) (terpri) (terpri))
        ;; Use `insert' instead of `princ', so control chars (e.g. \377) insert correctly.
        (with-current-buffer "*Help*" (insert (substitute-command-keys (concat "\\{" name "}"))))))))

(defun Info-make-manuals-xref (object &optional no-newlines-after-p manuals-spec nomsg)
    "Create a cross-ref link for index entries for OBJECT in manuals.
Non-`nil' optional arg NO-NEWLINES-AFTER-P means do not add two
newlines after the cross reference.

Optional arg MANUALS-SPEC controls which manuals to search.  It has
the same form as option `help-cross-reference-manuals', and it
defaults to the value of that option.

Do nothing if the car of MANUALS-SPEC is nil (no manuals to search).
If its cdr is `nil' then create the link without first searching any
manuals.  Otherwise, create the link only if there are search hits in
the manuals."
    (when (or (stringp object)  (symbolp object)) ; Exclude, e.g., a keymap as OBJECT.
      (unless manuals-spec (setq manuals-spec  help-cross-reference-manuals))
      (when (car manuals-spec) ; Create no link if no manuals to search.
        (let ((books         (car manuals-spec))
              (search-now-p  (cdr manuals-spec))
              (symb-name     (if (stringp object) object (symbol-name object))))
          (when (or (not search-now-p)
                    (save-current-buffer (Info-first-index-occurrence symb-name () books nomsg)))
            (let ((buffer-read-only  nil)
                  (nl-before         (cond ((and (eq ?\n (char-before)) ; Quicker than `looking-back', apparently.
                                                 (eq ?\n (char-before (1- (point))))) "")
                                           ((eq ?\n (char-before))                    "\n")
                                           (t                                         "\n\n"))))
              (insert (format "%sFor more information %s the " nl-before (if (cdr manuals-spec) "see" "check")))
              (help-insert-xref-button "manuals" 'help-info-manual-lookup symb-name () books)
              (insert ".")
              (unless no-newlines-after-p (insert "\n\n"))))))))

(defcustom help-cross-reference-manuals '(("emacs" "elisp"))
  "*Manuals to search, for a `*Help*' buffer link to the manuals.
A cons.

 The car is a list of manuals to search, or the symbol `all', to
  search all.  If nil, then do not create a cross-reference link.

 The cdr is a boolean:

  Non-`nil' means search the manuals, then create a cross-ref link:
        create it only if some search hits are found.

  `nil' means create a cross-ref link without searching manuals
        first (but only if there are some manuals to search)."
  :set #'(lambda (sym defs) (custom-set-default sym defs) (setq Info-indexed-nodes  ()))
  :type '(cons
          (choice :tag "Which Manuals"
                  (repeat :tag "Specific Manuals (files)" string)
                  (const  :tag "All Manuals" all))
          (boolean :tag "Search Before Creating Button?"))
  :group 'help)


(provide 'init-utils)
